Oui, c’est possible — **sans accolades** et **sans parenthèses après `write`** — en faisant de `write`… **un objet** (ou une valeur) qui expose des méthodes.
Du coup l’entrée devient simplement : `write.log("…")`, `write.level(ERROR).tag("…").msg("…").commit()`, etc.

Voici un design propre et minimal.

---

# 1) Appel simple : `write.log("…")`

```kotlin
object write {
    fun log(msg: String) {
        // point de terminaison simple
        AndroidSink.emit(LogLevel.INFO, defaultTag, msg)
    }
    
    fun level(level: LogLevel): LogChain = LogChain(level)
    fun debug(): LogChain = LogChain(LogLevel.DEBUG)
    fun info(): LogChain = LogChain(LogLevel.INFO)
    fun warn(): LogChain = LogChain(LogLevel.WARN)
    fun error(): LogChain = LogChain(LogLevel.ERROR)
    
    private const val defaultTag = "Sigma"
}
```

* Ici, **`write` est un `object`** : pas besoin de parenthèses pour y accéder.
* `write.log("…")` fonctionne immédiatement (méthode “terminal” qui écrit).

---

# 2) Chaînage fluide : `write.level(ERROR).tag("Sigma").kv("count", 3).msg("ok").commit()`

```kotlin
enum class LogLevel { DEBUG, INFO, WARN, ERROR }

class LogChain(
    private var level: LogLevel,
    private var tag: String = "Sigma",
) {
    private val fields = linkedMapOf<String, Any?>()
    private var message: String? = null
    
    fun tag(t: String) = apply { tag = t }
    fun kv(key: String, value: Any?) = apply { fields[key] = value }
    fun kv(pair: Pair<String, Any?>) = apply { fields[pair.first] = pair.second }
    fun msg(text: String) = apply { message = text }
    fun msg(block: () -> String) = apply { message = block() } // lazy si tu veux
    fun commit() {
        val body = buildString {
            message?.let { append(it) }
            if (fields.isNotEmpty()) {
                if (isNotEmpty()) append(" | ")
                append(fields.entries.joinToString(" ") { (k, v) -> "$k=$v" })
            }
        }
        AndroidSink.emit(level, tag, body)
    }
}
```

---

# 3) Un “sink” Android simple

```kotlin
object AndroidSink {
    fun emit(level: LogLevel, tag: String, msg: String) {
        when (level) {
            LogLevel.DEBUG -> android.util.Log.d(tag, msg)
            LogLevel.INFO  -> android.util.Log.i(tag, msg)
            LogLevel.WARN  -> android.util.Log.w(tag, msg)
            LogLevel.ERROR -> android.util.Log.e(tag, msg)
        }
    }
}
```

---

## Exemples d’usage

```kotlin
// Forme la plus simple
write.log("Démarrage")

// Chaînage
write.level(LogLevel.ERROR)
     .tag("SigmaFolder/Move")
     .kv("count", 3)
     .kv("path", somePath)
     .msg { "Copie terminée en ${elapsed}ms" }
     .commit()

// Raccourcis par niveau
write.error()
     .tag("SigmaFolder/Scanner")
     .msg("Échec d'indexation")
     .commit()
```

---

## Variantes possibles (toujours sans parenthèses après `write`)

* **Propriété-fonction** pour un style encore plus direct :

  ```kotlin
  object write {
      val log: (String) -> Unit = { msg -> AndroidSink.emit(LogLevel.INFO, "Sigma", msg) }
  }
  // usage
  write.log("Hello")   // `log` est une propriété de type fonction
  ```
* **Infix** (sans point, si tu aimes) : `write log "Hello"`

  ```kotlin
  object write
  infix fun write.log(msg: String) {
      AndroidSink.emit(LogLevel.INFO, "Sigma", msg)
  }
  // usage
  write log "Bonjour"
  ```

---

### Pourquoi ça répond à ton besoin

* `write` n’a **pas de parenthèses** → c’est une **valeur** (un `object`) qui sert de **point d’entrée**.
* Tu peux **enchaîner des appels** façon fluent avec un **builder** (`LogChain`) qui ne s’active qu’à `commit()`.
* Tu as **les deux styles** : “one-shot” (`write.log("…")`) et “DSL fluide” (`write.level(...).tag(...).msg(...).commit()`).

Si tu veux, je te fournis un **fichier unique prêt à coller** (avec filtrage par build type, tags hiérarchiques, et option d’écriture dans un fichier avec rotation).

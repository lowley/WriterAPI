Oui, c‚Äôest possible ‚Äî et m√™me idiomatique en Kotlin ‚Äî d‚Äô¬´ entrer ¬ª dans un DSL **sans parenth√®ses apr√®s `write`** gr√¢ce au **trailing lambda** et √† une **lambda avec receveur**.  
L‚Äôid√©e : `write { ‚Ä¶ }` (pas de `()`) ouvre un bloc configurant un _builder_ qui, √† la fin, √©crit la ligne de log.

Voici trois options croissantes en ‚ÄúDSL-ness‚Äù.

---

# Option A ‚Äî La plus simple et idiomatique

Usage :

```kotlin
write {
    level(ERROR)
    tag("SigmaFolder")
    kv("folder" to path)
    msg { "Move done in ${elapsed}ms" }   // lazy: √©valu√© seulement si n√©cessaire
}
```

Impl√©mentation :

```kotlin
@DslMarker
annotation class LogDslMarker

enum class LogLevel(val android: Int) { VERBOSE(Log.VERBOSE), DEBUG(Log.DEBUG),
    INFO(Log.INFO), WARN(Log.WARN), ERROR(Log.ERROR) }

@LogDslMarker
class LogDsl(
    private val sink: (LogLevel, String, String) -> Unit,
    private val isEnabled: (LogLevel, String) -> Boolean
) {
    private var level: LogLevel = LogLevel.DEBUG
    private var tag: String = "Sigma"
    private val fields = mutableListOf<Pair<String, Any?>>()
    private var messageProducer: (() -> String)? = null

    fun level(lvl: LogLevel) { level = lvl }
    fun tag(t: String) { tag = t }
    fun kv(pair: Pair<String, Any?>) { fields += pair }
    fun kv(key: String, value: Any?) { fields += key to value }
    fun msg(text: String) { messageProducer = { text } }
    fun msg(block: () -> String) { messageProducer = block }

    internal fun commit() {
        if (!isEnabled(level, tag)) return
        val msg = buildString {
            messageProducer?.let { append(it()) }
            if (fields.isNotEmpty()) {
                if (isNotBlank()) append(" | ")
                append(fields.joinToString(" ") { (k, v) -> "$k=$v" })
            }
        }
        sink(level, tag, msg)
    }
}

// Point d‚Äôentr√©e du DSL ‚Äî sans parenth√®ses: write { ‚Ä¶ }
inline fun write(block: LogDsl.() -> Unit) {
    val dsl = LogDsl(
        sink = { lvl, tag, text -> Log.println(lvl.android, tag, text) },
        isEnabled = { lvl, tag -> Log.isLoggable(tag, lvl.android) }
    )
    dsl.block()
    dsl.commit()
}
```

üëÄ Remarques

- **Pas de parenth√®ses** apr√®s `write` : le trailing-lambda suffit (`write { ‚Ä¶ }`).
    
- `msg { ‚Ä¶ }` permet un **log paresseux** (co√ªts d‚Äôassemblage √©vit√©s si le niveau n‚Äôest pas activ√©).
    
- `kv` aligne proprement des champs cl√©=valeur, pratique pour parser/filtrer.
    

---

# Option B ‚Äî DSL ‚Äúfluide‚Äù √† la lisibilit√© renforc√©e

Usage :

```kotlin
write {
    ERROR() tag "SigmaFolder" msg { "copy ok" } kv ("size" to bytes)
}
```

Impl√©mentation (ajouts par rapport √† A) :

```kotlin
@LogDslMarker
class LogDsl(/* ... m√™me ctor ... */) {
    /* ‚Ä¶ m√™mes membres ‚Ä¶ */

    // Petites aides "fluentes"
    fun ERROR() { level(LogLevel.ERROR) }
    fun WARN() { level(LogLevel.WARN) }
    fun INFO() { level(LogLevel.INFO) }
    fun DEBUG() { level(LogLevel.DEBUG) }

    infix fun tag(t: String) { tag(t) }
    infix fun msg(text: String) { msg(text) }
    infix fun kv(pair: Pair<String, Any?>) { kv(pair) }
}
```

---

# Option C ‚Äî DSL ‚Äúz√©ro points/z√©ro parenth√®ses‚Äù fa√ßon langage naturel

Usage :

```kotlin
write entry {
    level ERROR
    tag  "SigmaFolder"
    message { "renamed ${src.name} -> ${dst.name}" }
    field  "count" to count
}
```

Impl√©mentation (noyau) :

```kotlin
object WriteToken
val write = WriteToken  // permet `write entry { ... }`

infix fun WriteToken.entry(block: FancyLogDsl.() -> Unit) {
    FancyLogDsl(/* sinks ‚Ä¶ */).apply(block).commit()
}

@LogDslMarker
class FancyLogDsl(/* ‚Ä¶ */) {
    var level: LogLevel = LogLevel.DEBUG
    infix fun level(l: LogLevel) { level = l }

    var tag: String = "Sigma"
    infix fun tag(t: String) { tag = t }

    fun message(block: () -> String) { /* ‚Ä¶ */ }
    fun field(pair: Pair<String, Any?>) { /* ‚Ä¶ */ }

    fun commit() { /* ‚Ä¶ */ }
}
```

Ici on combine **valeurs-jetons** (`write`), **infix** et **lambda-receivers** pour un style tr√®s libre.

---

## Int√©gration ‚ÄúSigma Folder‚Äù

- Remplace `sink` par votre **routeur** (Logcat, fichier, Telemetry/Crashlytics, console debug).
    
- Gardez le **lazy logging** pour les chemins verbeux (ex. liste d‚Äôitems, JSON).
    
- Ajoutez un **prefixe de contexte** (ex. `tag("$baseTag/$sub")`), ou un `context("FolderView")` qui pousse un champ implicite.
    
- Si vous avez un **`BuildConfig.DEBUG`**, branchez `isEnabled` dessus pour couper net en prod.
    

Exemple d‚Äôenrobage :

```kotlin
object SigmaLog {
    fun init(
        sink: (LogLevel, String, String) -> Unit = { lvl, tag, msg -> Log.println(lvl.android, tag, msg) },
        enabled: (LogLevel, String) -> Boolean = { lvl, tag -> Log.isLoggable(tag, lvl.android) }
    ) {
        globalSink = sink
        globalEnabled = enabled
    }
    internal var globalSink = { l: LogLevel, t: String, m: String -> Log.println(l.android, t, m) }
    internal var globalEnabled = { l: LogLevel, t: String -> Log.isLoggable(t, l.android) }
}

inline fun write(block: LogDsl.() -> Unit) {
    val dsl = LogDsl(SigmaLog.globalSink, SigmaLog.globalEnabled)
    dsl.block()
    dsl.commit()
}
```

---

## Quand choisir quelle option ?

- **A** : simple, idiomatique, robuste ‚Äî recommand√© pour d√©marrer.
    
- **B** : lisibilit√© ‚Äúfluide‚Äù si l‚Äô√©quipe aime le style sans points ni parenth√®ses.
    
- **C** : style ‚Äúlangage naturel‚Äù maximal, au prix d‚Äôun peu plus de _plomberie_.
    

Si tu veux, je te fais une **petite librairie Kotlin** pr√™te √† copier (fichier unique) avec A + B, un `@DslMarker`, du **timestamp**, un **writer vers fichier** (rotations simples), et 2-3 **presets** (DEBUG, ERROR, TRACE).
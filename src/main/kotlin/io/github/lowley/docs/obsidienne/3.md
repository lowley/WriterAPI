Oui ! Tu peux **te passer totalement des “méthodes d’entrée”** (type `level()`, `error()`, etc.) _et_ garder `write` **sans parenthèses**, en faisant que **toute** première méthode (`tag`, `kv`, `msg`, …) puisse démarrer la chaîne.

Le truc :

- `write` est un **objet singleton** (pas d’appel, donc pas de `()`),
    
- et **chaque** méthode du DSL existe en **deux versions** :
    
    1. une **extension sur `write`** qui crée un nouveau `LogChain` (starter),
        
    2. la **même méthode sur `LogChain`** pour continuer le chaînage.
        

Ainsi tu peux commencer par **n’importe laquelle** : `write.tag(...)`, `write.msg(...)`, `write.kv(...)`, etc.

---

### Exemple minimal

```kotlin
// 1) Point d’entrée sans parenthèses
object write

// 2) Chaîne de log
class LogChain(
    private var tag: String = "Sigma",
) {
    private val fields = linkedMapOf<String, Any?>()
    private var message: String? = null

    // --- Méthodes de chaînage ---
    fun tag(t: String) = apply { tag = t }
    fun kv(key: String, value: Any?) = apply { fields[key] = value }
    fun kv(pair: Pair<String, Any?>) = apply { fields[pair.first] = pair.second }
    fun msg(text: String) = apply { message = text }
    fun msg(block: () -> String) = apply { message = block() }

    fun commit() {
        val body = buildString {
            message?.let { append(it) }
            if (fields.isNotEmpty()) {
                if (isNotEmpty()) append(" | ")
                append(fields.entries.joinToString(" ") { (k, v) -> "$k=$v" })
            }
        }
        AndroidSink.emit("I", tag, body) // ici niveau INFO fixe, si tu ne veux pas de niveaux
    }
}

// 3) Starters : mêmes noms… mais en extensions sur `write`
//    Toute première méthode peut démarrer la chaîne.
fun write.tag(t: String) = LogChain().tag(t)
fun write.kv(key: String, value: Any?) = LogChain().kv(key, value)
fun write.kv(pair: Pair<String, Any?>) = LogChain().kv(pair)
fun write.msg(text: String) = LogChain().msg(text)
fun write.msg(block: () -> String) = LogChain().msg(block)

// 4) Sink (remplace par Logcat, fichier, etc.)
object AndroidSink {
    fun emit(level: String, tag: String, msg: String) {
        android.util.Log.i(tag, msg) // ou routeur maison
    }
}
```

#### Usage (ordre libre, pas de méthode d’entrée dédiée)

```kotlin
write.msg("Démarrage").commit()

write.tag("SigmaFolder/Scanner")
     .kv("count", 3)
     .msg { "Indexation OK en ${elapsed}ms" }
     .commit()

write.kv("path", path).msg("Copie terminée").commit()

// Tu peux aussi démarrer par kv(), puis tag(), puis msg()… l’ordre n’a pas d’importance.
```

---

### Notes pratiques

- **Pas de parenthèses** après `write` (c’est un `object`).
    
- **Aucune “méthode d’entrée” obligatoire** : la _première_ méthode appelée sur `write` crée une nouvelle `LogChain`.
    
- Si tu veux un “one-shot” encore plus court, ajoute une extension terminale :
    
    ```kotlin
    fun write.log(text: String) { LogChain().msg(text).commit() }
    // usage : write.log("Bonjour")
    ```
    
- Si un jour tu veux réintroduire des niveaux, tu peux faire pareil :  
    `fun write.error() = LogChain(/* … */)` mais **ce n’est pas nécessaire** si tu n’en veux pas.
    

Si tu veux, je te fournis une version “fichier unique” prête à coller avec : tag hiérarchique, filtrage build type, et un sink vers fichier (rotation simple).